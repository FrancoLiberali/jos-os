
Poner un breakpoint en env_pop_tf() y continuar la ejecución hasta allí.

$ make gdb
gdb -q -s obj/kern/kernel -ex 'target remote 127.0.0.1:26000' -n -x .gdbinit
Leyendo símbolos desde obj/kern/kernel...hecho.
Remote debugging using 127.0.0.1:26000
0x0000fff0 in ?? ()
(gdb) b env_pop_tf
Punto de interrupción 1 at 0xf0102cf4: file kern/env.c, line 478.
(gdb) c
Continuando.
Se asume que la arquitectura objetivo es i386
=> 0xf0102cf4 <env_pop_tf>:	push   %ebp

Breakpoint 1, env_pop_tf (tf=0xf01d8000) at kern/env.c:478
478	{
(gdb) 


En QEMU, entrar en modo monitor (Ctrl-a c), y mostrar las cinco primeras líneas del comando info registers.

(qemu) info registers
EAX=f01d8000 EBX=f01d8000 ECX=f0197000 EDX=00000000
ESI=00010074 EDI=00000000 EBP=f010dfd8 ESP=f010dfbc
EIP=f0102cf4 EFL=00000092 [--S-A--] CPL=0 II=0 A20=1 SMM=0 HLT=0
ES =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]
CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]

De vuelta a GDB, imprimir el valor del argumento tf:

(gdb) p tf
$1 = (struct Trapframe *) 0xf01d8000

Imprimir, con x/Nx tf tantos enteros como haya en el struct Trapframe donde N = sizeof(Trapframe) / sizeof(int).

(gdb) x/17x tf
0xf01d8000:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01d8010:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01d8020:	0x00000023	0x00000023	0x00000000	0x00000000
0xf01d8030:	0x00800020	0x0000001b	0x00000000	0xeebfe000
0xf01d8040:	0x00000023

Avanzar hasta justo después del movl ...,%esp, usando si M para ejecutar tantas instrucciones como sea necesario en un solo paso:

(gdb) disas
Dump of assembler code for function env_pop_tf:
=> 0xf0102cf4 <+0>:	push   %ebp
   0xf0102cf5 <+1>:	mov    %esp,%ebp
   0xf0102cf7 <+3>:	sub    $0xc,%esp
   0xf0102cfa <+6>:	mov    0x8(%ebp),%esp
   0xf0102cfd <+9>:	popa   
   0xf0102cfe <+10>:	pop    %es
   0xf0102cff <+11>:	pop    %ds
   0xf0102d00 <+12>:	add    $0x8,%esp
   0xf0102d03 <+15>:	iret   
   0xf0102d04 <+16>:	push   $0xf01051e8
   0xf0102d09 <+21>:	push   $0x1e8
   0xf0102d0e <+26>:	push   $0xf0105186
   0xf0102d13 <+31>:	call   0xf01000a9 <_panic>
End of assembler dump.
(gdb) si 3
=> 0xf0102cfa <env_pop_tf+6>:	mov    0x8(%ebp),%esp
479		asm volatile("\tmovl %0,%%esp\n"

(gdb) x/17x $sp
0xf010dfac:	0x00010074	0x00010074	0x00000000	0xf010dfd8
0xf010dfbc:	0xf0102d55	0xf01d8000	0x00000003	0xf010dfd0
0xf010dfcc:	0xf01d8000	0xf010dfd8	0x00010074	0xf010dff8
0xf010dfdc:	0xf01000a9	0xf01d8000	0x00000000	0x00001f10
0xf010dfec:	0x00000000
(gdb) si
=> 0xf0102cfd <env_pop_tf+9>:	popa   
0xf0102cfd	479		asm volatile("\tmovl %0,%%esp\n"
(gdb) x/17x $sp
0xf01d8000:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01d8010:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01d8020:	0x00000023	0x00000023	0x00000000	0x00000000
0xf01d8030:	0x00800020	0x0000001b	0x00000000	0xeebfe000
0xf01d8040:	0x00000023

(gdb) si
=> 0xf0102cfe <env_pop_tf+10>:	pop    %es
0xf0102cfe in env_pop_tf (tf=<unavailable>) at kern/env.c:479
479		asm volatile("\tmovl %0,%%esp\n"
(gdb) si
=> 0xf0102cff <env_pop_tf+11>:	pop    %ds
0xf0102cff	479		asm volatile("\tmovl %0,%%esp\n"
(gdb) si
=> 0xf0102d00 <env_pop_tf+12>:	add    $0x8,%esp
0xf0102d00	479		asm volatile("\tmovl %0,%%esp\n"
(gdb) si
=> 0xf0102d03 <env_pop_tf+15>:	iret   
0xf0102d03	479		asm volatile("\tmovl %0,%%esp\n"


(qemu) info registers
EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000000
ESI=00000000 EDI=00000000 EBP=00000000 ESP=f01d8030
EIP=f0102d03 EFL=00000096 [--S-AP-] CPL=0 II=0 A20=1 SMM=0 HLT=0
ES =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]

(gdb) 
=> 0x800020:	cmp    $0xeebfe000,%esp
0x00800020 in ?? ()
(gdb) p $pc
$1 = (void (*)()) 0x800020
(gdb) symbol-file obj/user/hello
¿Cargar una tabla de símbolos nueva desde «obj/user/hello»? (y or n) y
Leyendo símbolos desde obj/user/hello...hecho.
Error in re-setting breakpoint 1: Función «env_pop_tf» no definida.
(gdb) p $pc
$2 = (void (*)()) 0x800020 <_start>
(gdb) tbreak syscall
Punto de interrupción temporal 2 at 0x8009f3: file lib/syscall.c, line 8.
(gdb) c
Continuando.
=> 0x8009f3 <syscall>:	push   %ebp

Temporary breakpoint 2, syscall (num=num@entry=0, check=check@entry=0, 
    a1=a1@entry=4005551752, a2=13, a3=0, a4=0, a5=0) at lib/syscall.c:8
8	{
(gdb) quit


